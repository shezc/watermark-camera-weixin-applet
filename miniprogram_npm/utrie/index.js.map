{"version":3,"sources":["utrie.umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n * utrie 1.0.1 <https://github.com/niklasvh/utrie>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.utrie = {}));\n}(this, (function (exports) { \n\n    var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i$1 = 0; i$1 < chars$1.length; i$1++) {\n        lookup$1[chars$1.charCodeAt(i$1)] = i$1;\n    }\n    var decode = function (base64) {\n        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n        if (base64[base64.length - 1] === '=') {\n            bufferLength--;\n            if (base64[base64.length - 2] === '=') {\n                bufferLength--;\n            }\n        }\n        var buffer = typeof ArrayBuffer !== 'undefined' &&\n            typeof Uint8Array !== 'undefined' &&\n            typeof Uint8Array.prototype.slice !== 'undefined'\n            ? new ArrayBuffer(bufferLength)\n            : new Array(bufferLength);\n        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);\n        for (i = 0; i < len; i += 4) {\n            encoded1 = lookup$1[base64.charCodeAt(i)];\n            encoded2 = lookup$1[base64.charCodeAt(i + 1)];\n            encoded3 = lookup$1[base64.charCodeAt(i + 2)];\n            encoded4 = lookup$1[base64.charCodeAt(i + 3)];\n            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n        }\n        return buffer;\n    };\n    var polyUint16Array = function (buffer) {\n        var length = buffer.length;\n        var bytes = [];\n        for (var i = 0; i < length; i += 2) {\n            bytes.push((buffer[i + 1] << 8) | buffer[i]);\n        }\n        return bytes;\n    };\n    var polyUint32Array = function (buffer) {\n        var length = buffer.length;\n        var bytes = [];\n        for (var i = 0; i < length; i += 4) {\n            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);\n        }\n        return bytes;\n    };\n\n    /** Shift size for getting the index-2 table offset. */\n    var UTRIE2_SHIFT_2 = 5;\n    /** Shift size for getting the index-1 table offset. */\n    var UTRIE2_SHIFT_1 = 6 + 5;\n    /**\n     * Shift size for shifting left the index array values.\n     * Increases possible data size with 16-bit index values at the cost\n     * of compactability.\n     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.\n     */\n    var UTRIE2_INDEX_SHIFT = 2;\n    /**\n     * Difference between the two shift sizes,\n     * for getting an index-1 offset from an index-2 offset. 6=11-5\n     */\n    var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;\n    /**\n     * The part of the index-2 table for U+D800..U+DBFF stores values for\n     * lead surrogate code _units_ not code _points_.\n     * Values for lead surrogate code _points_ are indexed with this portion of the table.\n     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)\n     */\n    var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;\n    /** Number of entries in a data block. 32=0x20 */\n    var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;\n    /** Mask for getting the lower bits for the in-data-block offset. */\n    var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;\n    var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;\n    /** Count the lengths of both BMP pieces. 2080=0x820 */\n    var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;\n    /**\n     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.\n     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.\n     */\n    var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;\n    var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */\n    /**\n     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.\n     * Variable length, for code points up to highStart, where the last single-value range starts.\n     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.\n     * (For 0x100000 supplementary code points U+10000..U+10ffff.)\n     *\n     * The part of the index-2 table for supplementary code points starts\n     * after this index-1 table.\n     *\n     * Both the index-1 table and the following part of the index-2 table\n     * are omitted completely if there is only BMP data.\n     */\n    var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;\n    /**\n     * Number of index-1 entries for the BMP. 32=0x20\n     * This part of the index-1 table is omitted from the serialized form.\n     */\n    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;\n    /** Number of entries in an index-2 block. 64=0x40 */\n    var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;\n    /** Mask for getting the lower bits for the in-index-2-block offset. */\n    var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;\n    var slice16 = function (view, start, end) {\n        if (view.slice) {\n            return view.slice(start, end);\n        }\n        return new Uint16Array(Array.prototype.slice.call(view, start, end));\n    };\n    var slice32 = function (view, start, end) {\n        if (view.slice) {\n            return view.slice(start, end);\n        }\n        return new Uint32Array(Array.prototype.slice.call(view, start, end));\n    };\n    var createTrieFromBase64 = function (base64, _byteLength) {\n        var buffer = decode(base64);\n        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);\n        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);\n        var headerLength = 24;\n        var index = slice16(view16, headerLength / 2, view32[4] / 2);\n        var data = view32[5] === 2\n            ? slice16(view16, (headerLength + view32[4]) / 2)\n            : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));\n        return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);\n    };\n    var Trie = /** @class */ (function () {\n        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {\n            this.initialValue = initialValue;\n            this.errorValue = errorValue;\n            this.highStart = highStart;\n            this.highValueIndex = highValueIndex;\n            this.index = index;\n            this.data = data;\n        }\n        /**\n         * Get the value for a code point as stored in the Trie.\n         *\n         * @param codePoint the code point\n         * @return the value\n         */\n        Trie.prototype.get = function (codePoint) {\n            var ix;\n            if (codePoint >= 0) {\n                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {\n                    // Ordinary BMP code point, excluding leading surrogates.\n                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.\n                    // 16 bit data is stored in the index array itself.\n                    ix = this.index[codePoint >> UTRIE2_SHIFT_2];\n                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n                    return this.data[ix];\n                }\n                if (codePoint <= 0xffff) {\n                    // Lead Surrogate Code Point.  A Separate index section is stored for\n                    // lead surrogate code units and code points.\n                    //   The main index has the code unit data.\n                    //   For this function, we need the code point data.\n                    // Note: this expression could be refactored for slightly improved efficiency, but\n                    //       surrogate code points will be so rare in practice that it's not worth it.\n                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];\n                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n                    return this.data[ix];\n                }\n                if (codePoint < this.highStart) {\n                    // Supplemental code point, use two-level lookup.\n                    ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);\n                    ix = this.index[ix];\n                    ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;\n                    ix = this.index[ix];\n                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n                    return this.data[ix];\n                }\n                if (codePoint <= 0x10ffff) {\n                    return this.data[this.highValueIndex];\n                }\n            }\n            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.\n            return this.errorValue;\n        };\n        return Trie;\n    }());\n\n    /*\n     * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i = 0; i < chars.length; i++) {\n        lookup[chars.charCodeAt(i)] = i;\n    }\n    var encode = function (arraybuffer) {\n        var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n        for (i = 0; i < len; i += 3) {\n            base64 += chars[bytes[i] >> 2];\n            base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n            base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n            base64 += chars[bytes[i + 2] & 63];\n        }\n        if (len % 3 === 2) {\n            base64 = base64.substring(0, base64.length - 1) + '=';\n        }\n        else if (len % 3 === 1) {\n            base64 = base64.substring(0, base64.length - 2) + '==';\n        }\n        return base64;\n    };\n\n    /**\n     * Trie2 constants, defining shift widths, index array lengths, etc.\n     *\n     * These are needed for the runtime macros but users can treat these as\n     * implementation details and skip to the actual public API further below.\n     */\n    // const UTRIE2_OPTIONS_VALUE_BITS_MASK = 0x000f;\n    /** Number of code points per index-1 table entry. 2048=0x800 */\n    var UTRIE2_CP_PER_INDEX_1_ENTRY = 1 << UTRIE2_SHIFT_1;\n    /** The alignment size of a data block. Also the granularity for compaction. */\n    var UTRIE2_DATA_GRANULARITY = 1 << UTRIE2_INDEX_SHIFT;\n    /* Fixed layout of the first part of the index array. ------------------- */\n    /**\n     * The BMP part of the index-2 table is fixed and linear and starts at offset 0.\n     * Length=2048=0x800=0x10000>>UTRIE2_SHIFT_2.\n     */\n    var UTRIE2_INDEX_2_OFFSET = 0;\n    var UTRIE2_MAX_INDEX_1_LENGTH = 0x100000 >> UTRIE2_SHIFT_1;\n    /*\n     * Fixed layout of the first part of the data array. -----------------------\n     * Starts with 4 blocks (128=0x80 entries) for ASCII.\n     */\n    /**\n     * The illegal-UTF-8 data block follows the ASCII block, at offset 128=0x80.\n     * Used with linear access for single bytes 0..0xbf for simple error handling.\n     * Length 64=0x40, not UTRIE2_DATA_BLOCK_LENGTH.\n     */\n    var UTRIE2_BAD_UTF8_DATA_OFFSET = 0x80;\n    /** The start of non-linear-ASCII data blocks, at offset 192=0xc0. */\n    var UTRIE2_DATA_START_OFFSET = 0xc0;\n    /* Building a Trie2 ---------------------------------------------------------- */\n    /*\n     * These definitions are mostly needed by utrie2_builder.c, but also by\n     * utrie2_get32() and utrie2_enum().\n     */\n    /*\n     * At build time, leave a gap in the index-2 table,\n     * at least as long as the maximum lengths of the 2-byte UTF-8 index-2 table\n     * and the supplementary index-1 table.\n     * Round up to UTRIE2_INDEX_2_BLOCK_LENGTH for proper compacting.\n     */\n    var UNEWTRIE2_INDEX_GAP_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;\n    var UNEWTRIE2_INDEX_GAP_LENGTH = (UTRIE2_UTF8_2B_INDEX_2_LENGTH + UTRIE2_MAX_INDEX_1_LENGTH + UTRIE2_INDEX_2_MASK) & ~UTRIE2_INDEX_2_MASK;\n    /**\n     * Maximum length of the build-time index-2 array.\n     * Maximum number of Unicode code points (0x110000) shifted right by UTRIE2_SHIFT_2,\n     * plus the part of the index-2 table for lead surrogate code points,\n     * plus the build-time index gap,\n     * plus the null index-2 block.\n     */\n    var UNEWTRIE2_MAX_INDEX_2_LENGTH = (0x110000 >> UTRIE2_SHIFT_2) +\n        UTRIE2_LSCP_INDEX_2_LENGTH +\n        UNEWTRIE2_INDEX_GAP_LENGTH +\n        UTRIE2_INDEX_2_BLOCK_LENGTH;\n    var UNEWTRIE2_INDEX_1_LENGTH = 0x110000 >> UTRIE2_SHIFT_1;\n    /**\n     * Maximum length of the build-time data array.\n     * One entry per 0x110000 code points, plus the illegal-UTF-8 block and the null block,\n     * plus values for the 0x400 surrogate code units.\n     */\n    var UNEWTRIE2_MAX_DATA_LENGTH = 0x110000 + 0x40 + 0x40 + 0x400;\n    /* Start with allocation of 16k data entries. */\n    var UNEWTRIE2_INITIAL_DATA_LENGTH = 1 << 14;\n    /* Grow about 8x each time. */\n    var UNEWTRIE2_MEDIUM_DATA_LENGTH = 1 << 17;\n    /** The null index-2 block, following the gap in the index-2 table. */\n    var UNEWTRIE2_INDEX_2_NULL_OFFSET = UNEWTRIE2_INDEX_GAP_OFFSET + UNEWTRIE2_INDEX_GAP_LENGTH;\n    /** The start of allocated index-2 blocks. */\n    var UNEWTRIE2_INDEX_2_START_OFFSET = UNEWTRIE2_INDEX_2_NULL_OFFSET + UTRIE2_INDEX_2_BLOCK_LENGTH;\n    /**\n     * The null data block.\n     * Length 64=0x40 even if UTRIE2_DATA_BLOCK_LENGTH is smaller,\n     * to work with 6-bit trail bytes from 2-byte UTF-8.\n     */\n    var UNEWTRIE2_DATA_NULL_OFFSET = UTRIE2_DATA_START_OFFSET;\n    /** The start of allocated data blocks. */\n    var UNEWTRIE2_DATA_START_OFFSET = UNEWTRIE2_DATA_NULL_OFFSET + 0x40;\n    /**\n     * The start of data blocks for U+0800 and above.\n     * Below, compaction uses a block length of 64 for 2-byte UTF-8.\n     * From here on, compaction uses UTRIE2_DATA_BLOCK_LENGTH.\n     * Data values for 0x780 code points beyond ASCII.\n     */\n    var UNEWTRIE2_DATA_0800_OFFSET = UNEWTRIE2_DATA_START_OFFSET + 0x780;\n    /**\n     * Maximum length of the runtime index array.\n     * Limited by its own 16-bit index values, and by uint16_t UTrie2Header.indexLength.\n     * (The actual maximum length is lower,\n     * (0x110000>>UTRIE2_SHIFT_2)+UTRIE2_UTF8_2B_INDEX_2_LENGTH+UTRIE2_MAX_INDEX_1_LENGTH.)\n     */\n    var UTRIE2_MAX_INDEX_LENGTH = 0xffff;\n    /**\n     * Maximum length of the runtime data array.\n     * Limited by 16-bit index values that are left-shifted by UTRIE2_INDEX_SHIFT,\n     * and by uint16_t UTrie2Header.shiftedDataLength.\n     */\n    var UTRIE2_MAX_DATA_LENGTH = 0xffff << UTRIE2_INDEX_SHIFT;\n    var BITS_16 = 16;\n    var BITS_32 = 32;\n    var isHighSurrogate = function (c) { return c >= 0xd800 && c <= 0xdbff; };\n    var equalInt = function (a, s, t, length) {\n        for (var i = 0; i < length; i++) {\n            if (a[s + i] !== a[t + i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var TrieBuilder = /** @class */ (function () {\n        function TrieBuilder(initialValue, errorValue) {\n            if (initialValue === void 0) { initialValue = 0; }\n            if (errorValue === void 0) { errorValue = 0; }\n            this.initialValue = initialValue;\n            this.errorValue = errorValue;\n            this.highStart = 0x110000;\n            this.data = new Uint32Array(UNEWTRIE2_INITIAL_DATA_LENGTH);\n            this.dataCapacity = UNEWTRIE2_INITIAL_DATA_LENGTH;\n            this.highStart = 0x110000;\n            this.firstFreeBlock = 0; /* no free block in the list */\n            this.isCompacted = false;\n            this.index1 = new Uint32Array(UNEWTRIE2_INDEX_1_LENGTH);\n            this.index2 = new Uint32Array(UNEWTRIE2_MAX_INDEX_2_LENGTH);\n            /*\n             * Multi-purpose per-data-block table.\n             *\n             * Before compacting:\n             *\n             * Per-data-block reference counters/free-block list.\n             *  0: unused\n             * >0: reference counter (number of index-2 entries pointing here)\n             * <0: next free data block in free-block list\n             *\n             * While compacting:\n             *\n             * Map of adjusted indexes, used in compactData() and compactIndex2().\n             * Maps from original indexes to new ones.\n             */\n            this.map = new Uint32Array(UNEWTRIE2_MAX_DATA_LENGTH >> UTRIE2_SHIFT_2);\n            /*\n             * preallocate and reset\n             * - ASCII\n             * - the bad-UTF-8-data block\n             * - the null data block\n             */\n            var i, j;\n            for (i = 0; i < 0x80; ++i) {\n                this.data[i] = initialValue;\n            }\n            for (; i < 0xc0; ++i) {\n                this.data[i] = errorValue;\n            }\n            for (i = UNEWTRIE2_DATA_NULL_OFFSET; i < UNEWTRIE2_DATA_START_OFFSET; ++i) {\n                this.data[i] = initialValue;\n            }\n            this.dataNullOffset = UNEWTRIE2_DATA_NULL_OFFSET;\n            this.dataLength = UNEWTRIE2_DATA_START_OFFSET;\n            /* set the index-2 indexes for the 2=0x80>>UTRIE2_SHIFT_2 ASCII data blocks */\n            for (i = 0, j = 0; j < 0x80; ++i, j += UTRIE2_DATA_BLOCK_LENGTH) {\n                this.index2[i] = j;\n                this.map[i] = 1;\n            }\n            /* reference counts for the bad-UTF-8-data block */\n            for (; j < 0xc0; ++i, j += UTRIE2_DATA_BLOCK_LENGTH) {\n                this.map[i] = 0;\n            }\n            /*\n             * Reference counts for the null data block: all blocks except for the ASCII blocks.\n             * Plus 1 so that we don't drop this block during compaction.\n             * Plus as many as needed for lead surrogate code points.\n             */\n            /* i==newTrie->dataNullOffset */\n            this.map[i++] = (0x110000 >> UTRIE2_SHIFT_2) - (0x80 >> UTRIE2_SHIFT_2) + 1 + UTRIE2_LSCP_INDEX_2_LENGTH;\n            j += UTRIE2_DATA_BLOCK_LENGTH;\n            for (; j < UNEWTRIE2_DATA_START_OFFSET; ++i, j += UTRIE2_DATA_BLOCK_LENGTH) {\n                this.map[i] = 0;\n            }\n            /*\n             * set the remaining indexes in the BMP index-2 block\n             * to the null data block\n             */\n            for (i = 0x80 >> UTRIE2_SHIFT_2; i < UTRIE2_INDEX_2_BMP_LENGTH; ++i) {\n                this.index2[i] = UNEWTRIE2_DATA_NULL_OFFSET;\n            }\n            /*\n             * Fill the index gap with impossible values so that compaction\n             * does not overlap other index-2 blocks with the gap.\n             */\n            for (i = 0; i < UNEWTRIE2_INDEX_GAP_LENGTH; ++i) {\n                this.index2[UNEWTRIE2_INDEX_GAP_OFFSET + i] = -1;\n            }\n            /* set the indexes in the null index-2 block */\n            for (i = 0; i < UTRIE2_INDEX_2_BLOCK_LENGTH; ++i) {\n                this.index2[UNEWTRIE2_INDEX_2_NULL_OFFSET + i] = UNEWTRIE2_DATA_NULL_OFFSET;\n            }\n            this.index2NullOffset = UNEWTRIE2_INDEX_2_NULL_OFFSET;\n            this.index2Length = UNEWTRIE2_INDEX_2_START_OFFSET;\n            /* set the index-1 indexes for the linear index-2 block */\n            for (i = 0, j = 0; i < UTRIE2_OMITTED_BMP_INDEX_1_LENGTH; ++i, j += UTRIE2_INDEX_2_BLOCK_LENGTH) {\n                this.index1[i] = j;\n            }\n            /* set the remaining index-1 indexes to the null index-2 block */\n            for (; i < UNEWTRIE2_INDEX_1_LENGTH; ++i) {\n                this.index1[i] = UNEWTRIE2_INDEX_2_NULL_OFFSET;\n            }\n            /*\n             * Preallocate and reset data for U+0080..U+07ff,\n             * for 2-byte UTF-8 which will be compacted in 64-blocks\n             * even if UTRIE2_DATA_BLOCK_LENGTH is smaller.\n             */\n            for (i = 0x80; i < 0x800; i += UTRIE2_DATA_BLOCK_LENGTH) {\n                this.set(i, initialValue);\n            }\n        }\n        /**\n         * Set a value for a code point.\n         *\n         * @param c the code point\n         * @param value the value\n         */\n        TrieBuilder.prototype.set = function (c, value) {\n            if (c < 0 || c > 0x10ffff) {\n                throw new Error('Invalid code point.');\n            }\n            this._set(c, true, value);\n            return this;\n        };\n        /**\n         * Set a value in a range of code points [start..end].\n         * All code points c with start<=c<=end will get the value if\n         * overwrite is TRUE or if the old value is the initial value.\n         *\n         * @param start the first code point to get the value\n         * @param end the last code point to get the value (inclusive)\n         * @param value the value\n         * @param overwrite flag for whether old non-initial values are to be overwritten\n         */\n        TrieBuilder.prototype.setRange = function (start, end, value, overwrite) {\n            if (overwrite === void 0) { overwrite = false; }\n            /*\n             * repeat value in [start..end]\n             * mark index values for repeat-data blocks by setting bit 31 of the index values\n             * fill around existing values if any, if(overwrite)\n             */\n            var block, rest, repeatBlock;\n            if (start > 0x10ffff || start < 0 || end > 0x10ffff || end < 0 || start > end) {\n                throw new Error('Invalid code point range.');\n            }\n            if (!overwrite && value === this.initialValue) {\n                return this; /* nothing to do */\n            }\n            if (this.isCompacted) {\n                throw new Error('Trie was already compacted');\n            }\n            var limit = end + 1;\n            if ((start & UTRIE2_DATA_MASK) !== 0) {\n                /* set partial block at [start..following block boundary[ */\n                block = this.getDataBlock(start, true);\n                var nextStart = (start + UTRIE2_DATA_BLOCK_LENGTH) & ~UTRIE2_DATA_MASK;\n                if (nextStart <= limit) {\n                    this.fillBlock(block, start & UTRIE2_DATA_MASK, UTRIE2_DATA_BLOCK_LENGTH, value, this.initialValue, overwrite);\n                    start = nextStart;\n                }\n                else {\n                    this.fillBlock(block, start & UTRIE2_DATA_MASK, limit & UTRIE2_DATA_MASK, value, this.initialValue, overwrite);\n                    return this;\n                }\n            }\n            /* number of positions in the last, partial block */\n            rest = limit & UTRIE2_DATA_MASK;\n            /* round down limit to a block boundary */\n            limit &= ~UTRIE2_DATA_MASK;\n            /* iterate over all-value blocks */\n            repeatBlock = value === this.initialValue ? this.dataNullOffset : -1;\n            while (start < limit) {\n                var i2 = void 0;\n                var setRepeatBlock = false;\n                if (value === this.initialValue && this.isInNullBlock(start, true)) {\n                    start += UTRIE2_DATA_BLOCK_LENGTH; /* nothing to do */\n                    continue;\n                }\n                /* get index value */\n                i2 = this.getIndex2Block(start, true);\n                i2 += (start >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;\n                block = this.index2[i2];\n                if (this.isWritableBlock(block)) {\n                    /* already allocated */\n                    if (overwrite && block >= UNEWTRIE2_DATA_0800_OFFSET) {\n                        /*\n                         * We overwrite all values, and it's not a\n                         * protected (ASCII-linear or 2-byte UTF-8) block:\n                         * replace with the repeatBlock.\n                         */\n                        setRepeatBlock = true;\n                    }\n                    else {\n                        /* !overwrite, or protected block: just write the values into this block */\n                        this.fillBlock(block, 0, UTRIE2_DATA_BLOCK_LENGTH, value, this.initialValue, overwrite);\n                    }\n                }\n                else if (this.data[block] !== value && (overwrite || block === this.dataNullOffset)) {\n                    /*\n                     * Set the repeatBlock instead of the null block or previous repeat block:\n                     *\n                     * If !isWritableBlock() then all entries in the block have the same value\n                     * because it's the null block or a range block (the repeatBlock from a previous\n                     * call to utrie2_setRange32()).\n                     * No other blocks are used multiple times before compacting.\n                     *\n                     * The null block is the only non-writable block with the initialValue because\n                     * of the repeatBlock initialization above. (If value==initialValue, then\n                     * the repeatBlock will be the null data block.)\n                     *\n                     * We set our repeatBlock if the desired value differs from the block's value,\n                     * and if we overwrite any data or if the data is all initial values\n                     * (which is the same as the block being the null block, see above).\n                     */\n                    setRepeatBlock = true;\n                }\n                if (setRepeatBlock) {\n                    if (repeatBlock >= 0) {\n                        this.setIndex2Entry(i2, repeatBlock);\n                    }\n                    else {\n                        /* create and set and fill the repeatBlock */\n                        repeatBlock = this.getDataBlock(start, true);\n                        this.writeBlock(repeatBlock, value);\n                    }\n                }\n                start += UTRIE2_DATA_BLOCK_LENGTH;\n            }\n            if (rest > 0) {\n                /* set partial block at [last block boundary..limit[ */\n                block = this.getDataBlock(start, true);\n                this.fillBlock(block, 0, rest, value, this.initialValue, overwrite);\n            }\n            return this;\n        };\n        /**\n         * Get the value for a code point as stored in the Trie2.\n         *\n         * @param codePoint the code point\n         * @return the value\n         */\n        TrieBuilder.prototype.get = function (codePoint) {\n            if (codePoint < 0 || codePoint > 0x10ffff) {\n                return this.errorValue;\n            }\n            else {\n                return this._get(codePoint, true);\n            }\n        };\n        TrieBuilder.prototype._get = function (c, fromLSCP) {\n            var i2;\n            if (c >= this.highStart && (!(c >= 0xd800 && c < 0xdc00) || fromLSCP)) {\n                return this.data[this.dataLength - UTRIE2_DATA_GRANULARITY];\n            }\n            if (c >= 0xd800 && c < 0xdc00 && fromLSCP) {\n                i2 = UTRIE2_LSCP_INDEX_2_OFFSET - (0xd800 >> UTRIE2_SHIFT_2) + (c >> UTRIE2_SHIFT_2);\n            }\n            else {\n                i2 = this.index1[c >> UTRIE2_SHIFT_1] + ((c >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK);\n            }\n            var block = this.index2[i2];\n            return this.data[block + (c & UTRIE2_DATA_MASK)];\n        };\n        TrieBuilder.prototype.freeze = function (valueBits) {\n            if (valueBits === void 0) { valueBits = BITS_32; }\n            var i;\n            var allIndexesLength;\n            var dataMove; /* >0 if the data is moved to the end of the index array */\n            /* compact if necessary */\n            if (!this.isCompacted) {\n                this.compactTrie();\n            }\n            allIndexesLength = this.highStart <= 0x10000 ? UTRIE2_INDEX_1_OFFSET : this.index2Length;\n            if (valueBits === BITS_16) {\n                // dataMove = allIndexesLength;\n                dataMove = 0;\n            }\n            else {\n                dataMove = 0;\n            }\n            /* are indexLength and dataLength within limits? */\n            if (\n            /* for unshifted indexLength */\n            allIndexesLength > UTRIE2_MAX_INDEX_LENGTH ||\n                /* for unshifted dataNullOffset */\n                dataMove + this.dataNullOffset > 0xffff ||\n                /* for unshifted 2-byte UTF-8 index-2 values */\n                dataMove + UNEWTRIE2_DATA_0800_OFFSET > 0xffff ||\n                /* for shiftedDataLength */\n                dataMove + this.dataLength > UTRIE2_MAX_DATA_LENGTH) {\n                throw new Error('Trie data is too large.');\n            }\n            var index = new Uint16Array(allIndexesLength);\n            /* write the index-2 array values shifted right by UTRIE2_INDEX_SHIFT, after adding dataMove */\n            var destIdx = 0;\n            for (i = 0; i < UTRIE2_INDEX_2_BMP_LENGTH; i++) {\n                index[destIdx++] = (this.index2[i] + dataMove) >> UTRIE2_INDEX_SHIFT;\n            }\n            /* write UTF-8 2-byte index-2 values, not right-shifted */\n            for (i = 0; i < 0xc2 - 0xc0; ++i) {\n                /* C0..C1 */\n                index[destIdx++] = dataMove + UTRIE2_BAD_UTF8_DATA_OFFSET;\n            }\n            for (; i < 0xe0 - 0xc0; ++i) {\n                /* C2..DF */\n                index[destIdx++] = dataMove + this.index2[i << (6 - UTRIE2_SHIFT_2)];\n            }\n            if (this.highStart > 0x10000) {\n                var index1Length = (this.highStart - 0x10000) >> UTRIE2_SHIFT_1;\n                var index2Offset = UTRIE2_INDEX_2_BMP_LENGTH + UTRIE2_UTF8_2B_INDEX_2_LENGTH + index1Length;\n                /* write 16-bit index-1 values for supplementary code points */\n                for (i = 0; i < index1Length; i++) {\n                    index[destIdx++] = UTRIE2_INDEX_2_OFFSET + this.index1[i + UTRIE2_OMITTED_BMP_INDEX_1_LENGTH];\n                }\n                /*\n                 * write the index-2 array values for supplementary code points,\n                 * shifted right by UTRIE2_INDEX_SHIFT, after adding dataMove\n                 */\n                for (i = 0; i < this.index2Length - index2Offset; i++) {\n                    index[destIdx++] = (dataMove + this.index2[index2Offset + i]) >> UTRIE2_INDEX_SHIFT;\n                }\n            }\n            /* write the 16/32-bit data array */\n            switch (valueBits) {\n                case BITS_16:\n                    /* write 16-bit data values */\n                    var data16 = new Uint16Array(this.dataLength);\n                    for (i = 0; i < this.dataLength; i++) {\n                        data16[i] = this.data[i];\n                    }\n                    return new Trie(this.initialValue, this.errorValue, this.highStart, dataMove + this.dataLength - UTRIE2_DATA_GRANULARITY, index, data16);\n                case BITS_32:\n                    /* write 32-bit data values */\n                    var data32 = new Uint32Array(this.dataLength);\n                    for (i = 0; i < this.dataLength; i++) {\n                        data32[i] = this.data[i];\n                    }\n                    return new Trie(this.initialValue, this.errorValue, this.highStart, dataMove + this.dataLength - UTRIE2_DATA_GRANULARITY, index, data32);\n                default:\n                    throw new Error('Bits should be either 16 or 32');\n            }\n        };\n        /*\n         * Find the start of the last range in the trie by enumerating backward.\n         * Indexes for supplementary code points higher than this will be omitted.\n         */\n        TrieBuilder.prototype.findHighStart = function (highValue) {\n            var value;\n            var i2, j, i2Block, prevI2Block, block, prevBlock;\n            /* set variables for previous range */\n            if (highValue === this.initialValue) {\n                prevI2Block = this.index2NullOffset;\n                prevBlock = this.dataNullOffset;\n            }\n            else {\n                prevI2Block = -1;\n                prevBlock = -1;\n            }\n            var prev = 0x110000;\n            /* enumerate index-2 blocks */\n            var i1 = UNEWTRIE2_INDEX_1_LENGTH;\n            var c = prev;\n            while (c > 0) {\n                i2Block = this.index1[--i1];\n                if (i2Block === prevI2Block) {\n                    /* the index-2 block is the same as the previous one, and filled with highValue */\n                    c -= UTRIE2_CP_PER_INDEX_1_ENTRY;\n                    continue;\n                }\n                prevI2Block = i2Block;\n                if (i2Block === this.index2NullOffset) {\n                    /* this is the null index-2 block */\n                    if (highValue !== this.initialValue) {\n                        return c;\n                    }\n                    c -= UTRIE2_CP_PER_INDEX_1_ENTRY;\n                }\n                else {\n                    /* enumerate data blocks for one index-2 block */\n                    for (i2 = UTRIE2_INDEX_2_BLOCK_LENGTH; i2 > 0;) {\n                        block = this.index2[i2Block + --i2];\n                        if (block === prevBlock) {\n                            /* the block is the same as the previous one, and filled with highValue */\n                            c -= UTRIE2_DATA_BLOCK_LENGTH;\n                            continue;\n                        }\n                        prevBlock = block;\n                        if (block === this.dataNullOffset) {\n                            /* this is the null data block */\n                            if (highValue !== this.initialValue) {\n                                return c;\n                            }\n                            c -= UTRIE2_DATA_BLOCK_LENGTH;\n                        }\n                        else {\n                            for (j = UTRIE2_DATA_BLOCK_LENGTH; j > 0;) {\n                                value = this.data[block + --j];\n                                if (value !== highValue) {\n                                    return c;\n                                }\n                                --c;\n                            }\n                        }\n                    }\n                }\n            }\n            /* deliver last range */\n            return 0;\n        };\n        /*\n         * Compact a build-time trie.\n         *\n         * The compaction\n         * - removes blocks that are identical with earlier ones\n         * - overlaps adjacent blocks as much as possible (if overlap==TRUE)\n         * - moves blocks in steps of the data granularity\n         * - moves and overlaps blocks that overlap with multiple values in the overlap region\n         *\n         * It does not\n         * - try to move and overlap blocks that are not already adjacent\n         */\n        TrieBuilder.prototype.compactData = function () {\n            var start, movedStart;\n            var blockLength, overlap;\n            var i, mapIndex, blockCount;\n            /* do not compact linear-ASCII data */\n            var newStart = UTRIE2_DATA_START_OFFSET;\n            for (start = 0, i = 0; start < newStart; start += UTRIE2_DATA_BLOCK_LENGTH, ++i) {\n                this.map[i] = start;\n            }\n            /*\n             * Start with a block length of 64 for 2-byte UTF-8,\n             * then switch to UTRIE2_DATA_BLOCK_LENGTH.\n             */\n            blockLength = 64;\n            blockCount = blockLength >> UTRIE2_SHIFT_2;\n            for (start = newStart; start < this.dataLength;) {\n                /*\n                 * start: index of first entry of current block\n                 * newStart: index where the current block is to be moved\n                 *           (right after current end of already-compacted data)\n                 */\n                if (start === UNEWTRIE2_DATA_0800_OFFSET) {\n                    blockLength = UTRIE2_DATA_BLOCK_LENGTH;\n                    blockCount = 1;\n                }\n                /* skip blocks that are not used */\n                if (this.map[start >> UTRIE2_SHIFT_2] <= 0) {\n                    /* advance start to the next block */\n                    start += blockLength;\n                    /* leave newStart with the previous block! */\n                    continue;\n                }\n                /* search for an identical block */\n                movedStart = this.findSameDataBlock(newStart, start, blockLength);\n                if (movedStart >= 0) {\n                    /* found an identical block, set the other block's index value for the current block */\n                    for (i = blockCount, mapIndex = start >> UTRIE2_SHIFT_2; i > 0; --i) {\n                        this.map[mapIndex++] = movedStart;\n                        movedStart += UTRIE2_DATA_BLOCK_LENGTH;\n                    }\n                    /* advance start to the next block */\n                    start += blockLength;\n                    /* leave newStart with the previous block! */\n                    continue;\n                }\n                /* see if the beginning of this block can be overlapped with the end of the previous block */\n                /* look for maximum overlap (modulo granularity) with the previous, adjacent block */\n                for (overlap = blockLength - UTRIE2_DATA_GRANULARITY; overlap > 0 && !equalInt(this.data, newStart - overlap, start, overlap); overlap -= UTRIE2_DATA_GRANULARITY) { }\n                if (overlap > 0 || newStart < start) {\n                    /* some overlap, or just move the whole block */\n                    movedStart = newStart - overlap;\n                    for (i = blockCount, mapIndex = start >> UTRIE2_SHIFT_2; i > 0; --i) {\n                        this.map[mapIndex++] = movedStart;\n                        movedStart += UTRIE2_DATA_BLOCK_LENGTH;\n                    }\n                    /* move the non-overlapping indexes to their new positions */\n                    start += overlap;\n                    for (i = blockLength - overlap; i > 0; --i) {\n                        this.data[newStart++] = this.data[start++];\n                    }\n                }\n                else {\n                    /* no overlap && newStart==start */\n                    for (i = blockCount, mapIndex = start >> UTRIE2_SHIFT_2; i > 0; --i) {\n                        this.map[mapIndex++] = start;\n                        start += UTRIE2_DATA_BLOCK_LENGTH;\n                    }\n                    newStart = start;\n                }\n            }\n            /* now adjust the index-2 table */\n            for (i = 0; i < this.index2Length; ++i) {\n                if (i === UNEWTRIE2_INDEX_GAP_OFFSET) {\n                    /* Gap indexes are invalid (-1). Skip over the gap. */\n                    i += UNEWTRIE2_INDEX_GAP_LENGTH;\n                }\n                this.index2[i] = this.map[this.index2[i] >> UTRIE2_SHIFT_2];\n            }\n            this.dataNullOffset = this.map[this.dataNullOffset >> UTRIE2_SHIFT_2];\n            /* ensure dataLength alignment */\n            while ((newStart & (UTRIE2_DATA_GRANULARITY - 1)) !== 0) {\n                this.data[newStart++] = this.initialValue;\n            }\n            this.dataLength = newStart;\n        };\n        TrieBuilder.prototype.findSameDataBlock = function (dataLength, otherBlock, blockLength) {\n            var block = 0;\n            /* ensure that we do not even partially get past dataLength */\n            dataLength -= blockLength;\n            for (; block <= dataLength; block += UTRIE2_DATA_GRANULARITY) {\n                if (equalInt(this.data, block, otherBlock, blockLength)) {\n                    return block;\n                }\n            }\n            return -1;\n        };\n        TrieBuilder.prototype.compactTrie = function () {\n            var highValue = this.get(0x10ffff);\n            /* find highStart and round it up */\n            var localHighStart = this.findHighStart(highValue);\n            localHighStart = (localHighStart + (UTRIE2_CP_PER_INDEX_1_ENTRY - 1)) & ~(UTRIE2_CP_PER_INDEX_1_ENTRY - 1);\n            if (localHighStart === 0x110000) {\n                highValue = this.errorValue;\n            }\n            /*\n             * Set trie->highStart only after utrie2_get32(trie, highStart).\n             * Otherwise utrie2_get32(trie, highStart) would try to read the highValue.\n             */\n            this.highStart = localHighStart;\n            if (this.highStart < 0x110000) {\n                /* Blank out [highStart..10ffff] to release associated data blocks. */\n                var suppHighStart = this.highStart <= 0x10000 ? 0x10000 : this.highStart;\n                this.setRange(suppHighStart, 0x10ffff, this.initialValue, true);\n            }\n            this.compactData();\n            if (this.highStart > 0x10000) {\n                this.compactIndex2();\n            }\n            /*\n             * Store the highValue in the data array and round up the dataLength.\n             * Must be done after compactData() because that assumes that dataLength\n             * is a multiple of UTRIE2_DATA_BLOCK_LENGTH.\n             */\n            this.data[this.dataLength++] = highValue;\n            while ((this.dataLength & (UTRIE2_DATA_GRANULARITY - 1)) !== 0) {\n                this.data[this.dataLength++] = this.initialValue;\n            }\n            this.isCompacted = true;\n        };\n        TrieBuilder.prototype.compactIndex2 = function () {\n            var i, start, movedStart, overlap;\n            /* do not compact linear-BMP index-2 blocks */\n            var newStart = UTRIE2_INDEX_2_BMP_LENGTH;\n            for (start = 0, i = 0; start < newStart; start += UTRIE2_INDEX_2_BLOCK_LENGTH, ++i) {\n                this.map[i] = start;\n            }\n            /* Reduce the index table gap to what will be needed at runtime. */\n            newStart += UTRIE2_UTF8_2B_INDEX_2_LENGTH + ((this.highStart - 0x10000) >> UTRIE2_SHIFT_1);\n            for (start = UNEWTRIE2_INDEX_2_NULL_OFFSET; start < this.index2Length;) {\n                /*\n                 * start: index of first entry of current block\n                 * newStart: index where the current block is to be moved\n                 *           (right after current end of already-compacted data)\n                 */\n                /* search for an identical block */\n                if ((movedStart = this.findSameIndex2Block(newStart, start)) >= 0) {\n                    /* found an identical block, set the other block's index value for the current block */\n                    this.map[start >> UTRIE2_SHIFT_1_2] = movedStart;\n                    /* advance start to the next block */\n                    start += UTRIE2_INDEX_2_BLOCK_LENGTH;\n                    /* leave newStart with the previous block! */\n                    continue;\n                }\n                /* see if the beginning of this block can be overlapped with the end of the previous block */\n                /* look for maximum overlap with the previous, adjacent block */\n                for (overlap = UTRIE2_INDEX_2_BLOCK_LENGTH - 1; overlap > 0 && !equalInt(this.index2, newStart - overlap, start, overlap); --overlap) { }\n                if (overlap > 0 || newStart < start) {\n                    /* some overlap, or just move the whole block */\n                    this.map[start >> UTRIE2_SHIFT_1_2] = newStart - overlap;\n                    /* move the non-overlapping indexes to their new positions */\n                    start += overlap;\n                    for (i = UTRIE2_INDEX_2_BLOCK_LENGTH - overlap; i > 0; --i) {\n                        this.index2[newStart++] = this.index2[start++];\n                    }\n                }\n                else {\n                    /* no overlap && newStart==start */ this.map[start >> UTRIE2_SHIFT_1_2] = start;\n                    start += UTRIE2_INDEX_2_BLOCK_LENGTH;\n                    newStart = start;\n                }\n            }\n            /* now adjust the index-1 table */\n            for (i = 0; i < UNEWTRIE2_INDEX_1_LENGTH; ++i) {\n                this.index1[i] = this.map[this.index1[i] >> UTRIE2_SHIFT_1_2];\n            }\n            this.index2NullOffset = this.map[this.index2NullOffset >> UTRIE2_SHIFT_1_2];\n            /*\n             * Ensure data table alignment:\n             * Needs to be granularity-aligned for 16-bit trie\n             * (so that dataMove will be down-shiftable),\n             * and 2-aligned for uint32_t data.\n             */\n            while ((newStart & ((UTRIE2_DATA_GRANULARITY - 1) | 1)) !== 0) {\n                /* Arbitrary value: 0x3fffc not possible for real data. */\n                this.index2[newStart++] = 0x0000ffff << UTRIE2_INDEX_SHIFT;\n            }\n            this.index2Length = newStart;\n        };\n        TrieBuilder.prototype.findSameIndex2Block = function (index2Length, otherBlock) {\n            /* ensure that we do not even partially get past index2Length */\n            index2Length -= UTRIE2_INDEX_2_BLOCK_LENGTH;\n            for (var block = 0; block <= index2Length; ++block) {\n                if (equalInt(this.index2, block, otherBlock, UTRIE2_INDEX_2_BLOCK_LENGTH)) {\n                    return block;\n                }\n            }\n            return -1;\n        };\n        TrieBuilder.prototype._set = function (c, forLSCP, value) {\n            if (this.isCompacted) {\n                throw new Error('Trie was already compacted');\n            }\n            var block = this.getDataBlock(c, forLSCP);\n            this.data[block + (c & UTRIE2_DATA_MASK)] = value;\n            return this;\n        };\n        TrieBuilder.prototype.writeBlock = function (block, value) {\n            var limit = block + UTRIE2_DATA_BLOCK_LENGTH;\n            while (block < limit) {\n                this.data[block++] = value;\n            }\n        };\n        TrieBuilder.prototype.isInNullBlock = function (c, forLSCP) {\n            var i2 = isHighSurrogate(c) && forLSCP\n                ? UTRIE2_LSCP_INDEX_2_OFFSET - (0xd800 >> UTRIE2_SHIFT_2) + (c >> UTRIE2_SHIFT_2)\n                : this.index1[c >> UTRIE2_SHIFT_1] + ((c >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK);\n            var block = this.index2[i2];\n            return block === this.dataNullOffset;\n        };\n        TrieBuilder.prototype.fillBlock = function (block, start, limit, value, initialValue, overwrite) {\n            var pLimit = block + limit;\n            if (overwrite) {\n                for (var i = block + start; i < pLimit; i++) {\n                    this.data[i] = value;\n                }\n            }\n            else {\n                for (var i = block + start; i < pLimit; i++) {\n                    if (this.data[i] === initialValue) {\n                        this.data[i] = value;\n                    }\n                }\n            }\n        };\n        TrieBuilder.prototype.setIndex2Entry = function (i2, block) {\n            ++this.map[block >> UTRIE2_SHIFT_2]; /* increment first, in case block==oldBlock! */\n            var oldBlock = this.index2[i2];\n            if (0 === --this.map[oldBlock >> UTRIE2_SHIFT_2]) {\n                this.releaseDataBlock(oldBlock);\n            }\n            this.index2[i2] = block;\n        };\n        TrieBuilder.prototype.releaseDataBlock = function (block) {\n            /* put this block at the front of the free-block chain */\n            this.map[block >> UTRIE2_SHIFT_2] = -this.firstFreeBlock;\n            this.firstFreeBlock = block;\n        };\n        TrieBuilder.prototype.getDataBlock = function (c, forLSCP) {\n            var i2 = this.getIndex2Block(c, forLSCP);\n            i2 += (c >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;\n            var oldBlock = this.index2[i2];\n            if (this.isWritableBlock(oldBlock)) {\n                return oldBlock;\n            }\n            /* allocate a new data block */\n            var newBlock = this.allocDataBlock(oldBlock);\n            this.setIndex2Entry(i2, newBlock);\n            return newBlock;\n        };\n        TrieBuilder.prototype.isWritableBlock = function (block) {\n            return block !== this.dataNullOffset && 1 === this.map[block >> UTRIE2_SHIFT_2];\n        };\n        TrieBuilder.prototype.getIndex2Block = function (c, forLSCP) {\n            if (c >= 0xd800 && c < 0xdc00 && forLSCP) {\n                return UTRIE2_LSCP_INDEX_2_OFFSET;\n            }\n            var i1 = c >> UTRIE2_SHIFT_1;\n            var i2 = this.index1[i1];\n            if (i2 === this.index2NullOffset) {\n                i2 = this.allocIndex2Block();\n                this.index1[i1] = i2;\n            }\n            return i2;\n        };\n        TrieBuilder.prototype.allocDataBlock = function (copyBlock) {\n            var newBlock;\n            if (this.firstFreeBlock !== 0) {\n                /* get the first free block */\n                newBlock = this.firstFreeBlock;\n                this.firstFreeBlock = -this.map[newBlock >> UTRIE2_SHIFT_2];\n            }\n            else {\n                /* get a new block from the high end */\n                newBlock = this.dataLength;\n                var newTop = newBlock + UTRIE2_DATA_BLOCK_LENGTH;\n                if (newTop > this.dataCapacity) {\n                    var capacity = void 0;\n                    /* out of memory in the data array */\n                    if (this.dataCapacity < UNEWTRIE2_MEDIUM_DATA_LENGTH) {\n                        capacity = UNEWTRIE2_MEDIUM_DATA_LENGTH;\n                    }\n                    else if (this.dataCapacity < UNEWTRIE2_MAX_DATA_LENGTH) {\n                        capacity = UNEWTRIE2_MAX_DATA_LENGTH;\n                    }\n                    else {\n                        /*\n                         * Should never occur.\n                         * Either UNEWTRIE2_MAX_DATA_LENGTH is incorrect,\n                         * or the code writes more values than should be possible.\n                         */\n                        throw new Error('Internal error in Trie creation.');\n                    }\n                    var newData = new Uint32Array(capacity);\n                    newData.set(this.data.subarray(0, this.dataLength));\n                    this.data = newData;\n                    this.dataCapacity = capacity;\n                }\n                this.dataLength = newTop;\n            }\n            this.data.set(this.data.subarray(copyBlock, copyBlock + UTRIE2_DATA_BLOCK_LENGTH), newBlock);\n            this.map[newBlock >> UTRIE2_SHIFT_2] = 0;\n            return newBlock;\n        };\n        TrieBuilder.prototype.allocIndex2Block = function () {\n            var newBlock = this.index2Length;\n            var newTop = newBlock + UTRIE2_INDEX_2_BLOCK_LENGTH;\n            if (newTop > this.index2.length) {\n                throw new Error('Internal error in Trie creation.');\n                /*\n                 * Should never occur.\n                 * Either UTRIE2_MAX_BUILD_TIME_INDEX_LENGTH is incorrect,\n                 * or the code writes more values than should be possible.\n                 */\n            }\n            this.index2Length = newTop;\n            this.index2.set(this.index2.subarray(this.index2NullOffset, this.index2NullOffset + UTRIE2_INDEX_2_BLOCK_LENGTH), newBlock);\n            return newBlock;\n        };\n        return TrieBuilder;\n    }());\n    var serializeBase64 = function (trie) {\n        var index = trie.index;\n        var data = trie.data;\n        if (!(index instanceof Uint16Array) || !(data instanceof Uint16Array || data instanceof Uint32Array)) {\n            throw new Error('TrieBuilder serializer only support TypedArrays');\n        }\n        var headerLength = Uint32Array.BYTES_PER_ELEMENT * 6;\n        var bufferLength = headerLength + index.byteLength + data.byteLength;\n        var buffer = new ArrayBuffer(Math.ceil(bufferLength / 4) * 4);\n        var view32 = new Uint32Array(buffer);\n        var view16 = new Uint16Array(buffer);\n        view32[0] = trie.initialValue;\n        view32[1] = trie.errorValue;\n        view32[2] = trie.highStart;\n        view32[3] = trie.highValueIndex;\n        view32[4] = index.byteLength;\n        // $FlowFixMe\n        view32[5] = data.BYTES_PER_ELEMENT;\n        view16.set(index, headerLength / Uint16Array.BYTES_PER_ELEMENT);\n        if (data.BYTES_PER_ELEMENT === Uint16Array.BYTES_PER_ELEMENT) {\n            view16.set(data, (headerLength + index.byteLength) / Uint16Array.BYTES_PER_ELEMENT);\n        }\n        else {\n            view32.set(data, Math.ceil((headerLength + index.byteLength) / Uint32Array.BYTES_PER_ELEMENT));\n        }\n        return [encode(new Uint8Array(buffer)), buffer.byteLength];\n    };\n\n    exports.Trie = Trie;\n    exports.TrieBuilder = TrieBuilder;\n    exports.createTrieFromBase64 = createTrieFromBase64;\n    exports.serializeBase64 = serializeBase64;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=utrie.umd.js.map\n"]}